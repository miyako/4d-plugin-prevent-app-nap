/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Prevent App Nap
 #	author : miyako
 #	2018/11/19
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

std::mutex mutexActivityId;

id <NSObject> activityId = nil;

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
        switch(selector)
        {
            case 1 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)END_IMPORTANT_ACTIVITY, params);
                break;
            case 2 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)BEGIN_IMPORTANT_ACTIVITY, params);
                break;
            case kCloseProcess :
                OnCloseProcess(params);
                break;
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
            case kDeinitPlugin :
                OnExit();
                break;
        }

	}
	catch(...)
	{

	}
}

bool IsProcessOnExit()
{
    C_TEXT name;
    PA_long32 state, time;
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
    CUTF16String procName(name.getUTF16StringPtr());
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

void OnStartup()
{

}

void OnExit()
{

}

void OnCloseProcess(PA_PluginParameters params)
{
    if(IsProcessOnExit())
    {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)END_IMPORTANT_ACTIVITY, params);
    }
}

// -------------------------------- Prevent App Nap -------------------------------


void END_IMPORTANT_ACTIVITY(PA_PluginParameters params)
{
	std::lock_guard<std::mutex> lock(mutexActivityId);

    if(activityId)
    {
        [[NSProcessInfo processInfo] endActivity:activityId];
        
        NSLog(@"endActivity");
       
        [activityId release];
        
        activityId = nil;
    };
}

void BEGIN_IMPORTANT_ACTIVITY(PA_PluginParameters params)
{
	C_LONGINT Param1;
	C_TEXT Param2;

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    NSActivityOptions options = 0;
    
    unsigned int option = Param1.getIntValue();
    
    if(option & 1)
        options |= NSActivityIdleDisplaySleepDisabled;
    if(option & 2)
        options |= NSActivityIdleSystemSleepDisabled;
    if(option & 4)
        options |= NSActivitySuddenTerminationDisabled;
    if(option & 8)
        options |= NSActivityAutomaticTerminationDisabled;
    
    NSString *reason = Param2.copyUTF16String();
    
    if(![reason length])
        reason = @"important activity";
    
    END_IMPORTANT_ACTIVITY(params);
    
    std::lock_guard<std::mutex> lock(mutexActivityId);
    
    activityId = [[NSProcessInfo processInfo] beginActivityWithOptions:options reason:reason];
    
    [activityId retain];
    
    NSLog(@"beginActivityWithOptions:%d", options);
    
    [reason release];
}

